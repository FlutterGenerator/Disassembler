package com.mcal.disassembler.utils;

import com.mcal.disassembler.nativeapi.DisassemblerClass;
import com.mcal.disassembler.nativeapi.DisassemblerSymbol;
import com.mcal.disassembler.nativeapi.DisassemblerVtable;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Vector;

public class HeaderGenerator {
    private final DisassemblerClass disassemblerClass;
    private final DisassemblerVtable vtable;
    private String[] namespace;
    private String className;

    public HeaderGenerator(@NotNull DisassemblerClass disassemblerClass, DisassemblerVtable vtable, String path) {
        this.disassemblerClass = disassemblerClass;
        this.vtable = vtable;

        this.className = disassemblerClass.getName();
        if (this.className.lastIndexOf("::") != -1) {
            this.className = this.className.substring(this.className.lastIndexOf("::") + 2);
        }
        try {
            String namespaces = disassemblerClass.getName().substring(0, disassemblerClass.getName().length() - className.length() - 2);
            this.namespace = namespaces.split("::");
        } catch (Exception e) {
            this.namespace = new String[0];
            e.printStackTrace();
        }
    }

    private static boolean hasItemInList(@NotNull Vector<DisassemblerSymbol> syms, DisassemblerSymbol sym) {
        for (DisassemblerSymbol iSym : syms) {
            if (sym.getDemangledName().equals(iSym.getDemangledName())) {
                return false;
            }
        }
        return true;
    }

    private static boolean isObjectItem(@NotNull DisassemblerSymbol sym) {
        String dname = sym.getDemangledName();
        String name = sym.getName();
        return !dname.contains("(") && !dname.contains(")") && name.startsWith("_ZN");
    }

    private static boolean isMethodItem(@NotNull DisassemblerSymbol sym) {
        String dname = sym.getDemangledName();
        String name = sym.getName();
        return dname.contains("(") && dname.contains(")") && name.startsWith("_ZN");
    }

    @androidx.annotation.Nullable
    @Nullable
    private String[] getExtendedClasses() {
        try {
            Vector<String> otherZTVs = new Vector<>();
            try {
                for (DisassemblerSymbol sym : vtable.getVtables())
                    if (isMethodBelongToOtherClass(sym)) {
                        boolean hasItem = false;
                        for (String str : otherZTVs)
                            if (str.equals(getOwnerClass(sym)))
                                hasItem = true;
                        if (!hasItem)
                            otherZTVs.addElement(getOwnerClass(sym));
                    }
            } catch (Exception e) {
                return null;
            }
            if (otherZTVs.isEmpty())
                return null;
            String[] ret = new String[otherZTVs.size()];
            for (int i = 0; i < otherZTVs.size(); ++i)
                ret[i] = otherZTVs.get(i);
            return ret;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private boolean isMethodBelongToOtherClass(@NotNull DisassemblerSymbol symbol) {
        return !symbol.getDemangledName().startsWith(disassemblerClass.getName());
    }

    @NotNull
    private String getOwnerClass(DisassemblerSymbol symbol) throws Exception {
        try {
            String dname = symbol.getDemangledName().substring(0, symbol.getDemangledName().indexOf("("));
            return dname.substring(0, dname.lastIndexOf("::"));
        } catch (Exception e) {
            throw new Exception("No owner class found.");
        }
    }

    public String[] generate() {
        Vector<String> lines = new Vector<>();
        try {
            lines.addElement("#ifndef _" + className.toUpperCase() + "_H");
            lines.addElement("#define _" + className.toUpperCase() + "_H");
            lines.addElement("");
            //lines.addElement("#pragma once");
            //lines.addElement("");
            lines.addElement("//This header template file is generated by Disassembler.");
            lines.addElement("");

            for (String space : namespace) {
                lines.addElement("namespace " + space + " {");
            }

            lines.addElement("class " + className + " {");
            String[] extendedClasses = getExtendedClasses();
            if (extendedClasses != null) {
                for (String str : extendedClasses) {
                    lines.addElement(" : public " + str);
                }
            }

            lines.addElement("public:");
            lines.addElement("    //Fields");
            lines.addElement("    char filler_" + className + "[UNKNOW_SIZE];");

            if (getVtables() != null) {
                lines.addElement("public:");
                lines.addElement("    //Virtual Tables");

                for (DisassemblerSymbol symbol : getVtables()) {
                    try {
                        if (symbol != null) {
                            String mname = getVirtualMethodDefinition(symbol);
                            lines.addElement("	" + mname + "// " + symbol.getName());
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }

            if (getMethods() != null) {
                lines.addElement("public:");
                lines.addElement("    //Methods");

                for (DisassemblerSymbol symbol : getMethods()) {
                    if (symbol != null) {
                        String mname = getMethodDefinition(symbol);
                        lines.addElement("    " + mname + "// " + symbol.getName());
                    }
                }
            }

            if (getObjects() != null) {
                lines.addElement("public:");
                lines.addElement("    //Objects");
                for (DisassemblerSymbol symbol : getObjects()) {
                    if (symbol != null) {
                        String mname = getObjectDefinition(symbol);
                        lines.addElement("    " + mname + "// " + symbol.getName());
                    }
                }
            }
            lines.addElement("};//" + className);
            for (String space : namespace) {
                lines.addElement("}//" + space);
            }
            lines.addElement("");
            lines.addElement("#endif // _" + className.toUpperCase() + "_H");
        } catch (Exception e) {
            e.printStackTrace();
        }
        String[] ret = new String[lines.size()];
        for (int i = 0; i < lines.size(); ++i) {
            ret[i] = lines.get(i);
        }
        return ret;
    }

    @NotNull
    private String getObjectDefinition(@NotNull DisassemblerSymbol symbol) {
        String name = symbol.getDemangledName().substring(disassemblerClass.getName().length() + 2);
        return "static " + disassemblerClass.getName() + " * " + name + ";";
    }

    @NotNull
    private String getMethodDefinition(@NotNull DisassemblerSymbol symbol) {
        String name = symbol.getDemangledName().substring(disassemblerClass.getName().length() + 2);
        if (name.startsWith("~" + className)) {
            return name + ";";
        }
        if (name.startsWith(className)) {
            return name + ";";
        }
        return "void " + name + ";";
    }

    @NotNull
    private String getVirtualMethodDefinition(@NotNull DisassemblerSymbol symbol) throws Exception {
        String name_ = symbol.getDemangledName();
        if (name_.equals("__cxa_pure_virtual")) {
            return "//pure virtual method";
        }
        if (!name_.startsWith(disassemblerClass.getName())) {
            throw new Exception("No owned vtable");
        }
        String name = symbol.getDemangledName().substring(disassemblerClass.getName().length() + 2);
        if (name.startsWith("~" + className)) {
            return "virtual " + name + ";";
        }
        if (name.startsWith(className)) {
            return "virtual " + name + ";";
        }
        return "virtual void " + name + ";";
    }

    @androidx.annotation.Nullable
    @Nullable
    private DisassemblerSymbol[] getObjects() {
        Vector<DisassemblerSymbol> symbols = new Vector<>();
        for (DisassemblerSymbol symbol : disassemblerClass.getSymbols()) {
            if (isObjectItem(symbol)) {
                symbols.addElement(symbol);
            }
        }
        DisassemblerSymbol[] ret = new DisassemblerSymbol[symbols.size()];
        for (int i = 0; i < symbols.size(); ++i) {
            ret[i] = symbols.get(i);
        }
        if (symbols.isEmpty()) {
            return null;
        }
        return ret;
    }

    @androidx.annotation.Nullable
    @Nullable
    private DisassemblerSymbol[] getVtables() {
        if (vtable == null) {
            return null;
        }
        if (vtable.getVtables().isEmpty()) {
            return null;
        }
        Vector<DisassemblerSymbol> symbols = vtable.getVtables();
        for (DisassemblerSymbol symbol : symbols) {
            if (hasItemInList(symbols, symbol)) {
                symbols.addElement(symbol);
            }
        }
        symbols = moveConOrDesToStart(symbols);
        DisassemblerSymbol[] ret = new DisassemblerSymbol[symbols.size()];
        for (int i = 0; i < symbols.size(); ++i) {
            ret[i] = symbols.get(i);
        }

        return ret;
    }

    @androidx.annotation.Nullable
    @Nullable
    private DisassemblerSymbol[] getMethods() {
        Vector<DisassemblerSymbol> symbols = new Vector<>();
        for (DisassemblerSymbol symbol : disassemblerClass.getSymbols()) {
            if (isMethodItem(symbol) && !isVtable(symbol) && hasItemInList(symbols, symbol)) {
                symbols.addElement(symbol);
            }
        }
        if (symbols.isEmpty()) {
            return null;
        }
        symbols = moveConOrDesToStart(symbols);
        DisassemblerSymbol[] ret = new DisassemblerSymbol[symbols.size()];
        for (int i = 0; i < symbols.size(); ++i) {
            ret[i] = symbols.get(i);
        }
        return ret;
    }

    private boolean isVtable(DisassemblerSymbol sym) {
        if (vtable == null) {
            return false;
        }
        for (DisassemblerSymbol symbol : vtable.getVtables()) {
            if (symbol.getDemangledName().equals(sym.getDemangledName())) {
                return true;
            }
        }
        return false;
    }

    @NotNull
    private Vector<DisassemblerSymbol> moveConOrDesToStart(@NotNull Vector<DisassemblerSymbol> syms) {
        Vector<DisassemblerSymbol> ret = new Vector<>();
        for (DisassemblerSymbol sym : syms) {
            if (isCon(sym)) {
                ret.addElement(sym);
            }
        }
        for (DisassemblerSymbol sym : syms) {
            if (isDes(sym)) {
                ret.addElement(sym);
            }
        }
        for (DisassemblerSymbol sym : syms) {
            if (!isDes(sym) && !isCon(sym)) {
                ret.addElement(sym);
            }
        }
        return ret;
    }

    private boolean isCon(DisassemblerSymbol symbol) {
        try {
            String name = symbol.getDemangledName().substring(disassemblerClass.getName().length() + 2);
            if (name.startsWith(className)) {
                return true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    private boolean isDes(DisassemblerSymbol symbol) {
        try {
            String name = symbol.getDemangledName().substring(disassemblerClass.getName().length() + 2);
            if (name.startsWith("~" + className)) {
                return true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }
}