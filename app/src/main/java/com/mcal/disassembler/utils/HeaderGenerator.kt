package com.mcal.disassembler.utils

import com.mcal.disassembler.nativeapi.DisassemblerClass
import com.mcal.disassembler.nativeapi.DisassemblerSymbol
import com.mcal.disassembler.nativeapi.DisassemblerVtable
import java.util.Locale
import java.util.Vector

class HeaderGenerator(
    private val disassemblerClass: DisassemblerClass,
    private val vtable: DisassemblerVtable?,
) {
    private var namespace: Array<String?>
    private var className: String

    init {
        className = disassemblerClass.name
        if (className.lastIndexOf("::") != -1) {
            className = className.substring(className.lastIndexOf("::") + 2)
        }
        try {
            val namespaces = disassemblerClass.name.substring(
                0,
                disassemblerClass.name.length - className.length - 2
            )
            namespace =
                namespaces.split("::".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
        } catch (e: Exception) {
            namespace = arrayOfNulls(0)
            e.printStackTrace()
        }
    }

    private val extendedClasses: Array<String?>?
        get() {
            try {
                val otherZTVs = Vector<String>()
                try {
                    vtable?.vtables?.forEach { sym ->
                        if (isMethodBelongToOtherClass(sym)) {
                            var hasItem = false
                            for (str in otherZTVs) {
                                if (str == getOwnerClass(sym)) {
                                    hasItem = true
                                }
                            }
                            if (!hasItem) {
                                otherZTVs.addElement(getOwnerClass(sym))
                            }
                        }
                    }
                } catch (e: Exception) {
                    return null
                }
                if (otherZTVs.isEmpty()) {
                    return null
                }
                val result = arrayOfNulls<String>(otherZTVs.size)
                for (i in otherZTVs.indices) {
                    result[i] = otherZTVs[i]
                }
                return result
            } catch (e: Exception) {
                e.printStackTrace()
            }
            return null
        }

    private fun isMethodBelongToOtherClass(symbol: DisassemblerSymbol): Boolean {
        return !symbol.demangledName.startsWith(disassemblerClass.name)
    }

    @Throws(Exception::class)
    private fun getOwnerClass(symbol: DisassemblerSymbol): String {
        return try {
            val dname = symbol.demangledName.substring(0, symbol.demangledName.indexOf("("))
            dname.substring(0, dname.lastIndexOf("::"))
        } catch (e: Exception) {
            throw Exception("No owner class found.")
        }
    }

    fun generate(): Array<String?> {
        val lines = Vector<String>()
        try {
            lines.addElement("#ifndef _" + className.uppercase(Locale.getDefault()) + "_H")
            lines.addElement("#define _" + className.uppercase(Locale.getDefault()) + "_H")
            lines.addElement("")
            //lines.addElement("#pragma once");
            //lines.addElement("");
            lines.addElement("// This header template file is generated by Disassembler.")
            lines.addElement("")
            for (space in namespace) {
                lines.addElement("namespace $space {")
            }
            lines.addElement("class $className {")
            val extendedClasses = extendedClasses
            if (extendedClasses != null) {
                for (str in extendedClasses) {
                    lines.addElement(" : public $str")
                }
            }
            lines.addElement("public:")
            lines.addElement("    // Fields")
            lines.addElement("    char filler_$className[UNKNOW_SIZE];")
            vtables?.let {
                lines.addElement("public:")
                lines.addElement("    // Virtual Tables")
                for (symbol in it) {
                    try {
                        if (symbol != null) {
                            val mname = getVirtualMethodDefinition(symbol)
                            lines.addElement("	" + mname + " // " + symbol.name)
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
            methods?.let {
                lines.addElement("public:")
                lines.addElement("    // Methods")
                for (symbol in it) {
                    if (symbol != null) {
                        val mname = getMethodDefinition(symbol)
                        lines.addElement("    " + mname + " // " + symbol.name)
                    }
                }
            }
            objects?.let {
                lines.addElement("public:")
                lines.addElement("    // Objects")
                for (symbol in it) {
                    if (symbol != null) {
                        val mname = getObjectDefinition(symbol)
                        lines.addElement("    " + mname + " // " + symbol.name)
                    }
                }
            }
            lines.addElement("}; // $className")
            for (space in namespace) {
                lines.addElement("} // $space")
            }
            lines.addElement("")
            lines.addElement("#endif // _" + className.uppercase(Locale.getDefault()) + "_H")
        } catch (e: Exception) {
            e.printStackTrace()
        }
        val result = arrayOfNulls<String>(lines.size)
        for (i in lines.indices) {
            result[i] = lines[i]
        }
        return result
    }

    private fun getObjectDefinition(symbol: DisassemblerSymbol): String {
        val name = symbol.demangledName.substring(disassemblerClass.name.length + 2)
        return "static " + disassemblerClass.name + " * " + name + ";"
    }

    private fun getMethodDefinition(symbol: DisassemblerSymbol): String {
        val name = symbol.demangledName.substring(disassemblerClass.name.length + 2)
        if (name.startsWith("~$className")) {
            return "$name;"
        }
        return if (name.startsWith(className)) {
            "$name;"
        } else "void $name;"
    }

    @Throws(Exception::class)
    private fun getVirtualMethodDefinition(symbol: DisassemblerSymbol): String {
        var name = symbol.demangledName
        if (name == "__cxa_pure_virtual") {
            return "// pure virtual method"
        }
        if (!name.startsWith(disassemblerClass.name)) {
            throw Exception("No owned vtable")
        }
        name = symbol.demangledName.substring(disassemblerClass.name.length + 2)
        if (name.startsWith("~$className")) {
            return "virtual $name;"
        }
        return if (name.startsWith(className)) {
            "virtual $name;"
        } else {
            "virtual void $name;"
        }
    }

    private val objects: Array<DisassemblerSymbol?>?
        get() {
            val symbols = Vector<DisassemblerSymbol>()
            for (symbol in disassemblerClass.symbols) {
                if (isObjectItem(symbol)) {
                    symbols.addElement(symbol)
                }
            }
            val result = arrayOfNulls<DisassemblerSymbol>(symbols.size)
            for (i in symbols.indices) {
                result[i] = symbols[i]
            }
            return if (symbols.isEmpty()) {
                null
            } else {
                result
            }
        }

    private val vtables: Array<DisassemblerSymbol?>?
        get() {
            if (vtable == null) {
                return null
            }
            if (vtable.vtables.isEmpty()) {
                return null
            }
            var symbols = vtable.vtables
            for (symbol in symbols) {
                if (hasItemInList(symbols, symbol)) {
                    symbols.addElement(symbol)
                }
            }
            symbols = moveConOrDesToStart(symbols)
            val result = arrayOfNulls<DisassemblerSymbol>(symbols.size)
            for (i in symbols.indices) {
                result[i] = symbols[i]
            }
            return result
        }

    private val methods: Array<DisassemblerSymbol?>?
        get() {
            var symbols = Vector<DisassemblerSymbol>()
            for (symbol in disassemblerClass.symbols) {
                if (isMethodItem(symbol) && !isVtable(symbol) && hasItemInList(symbols, symbol)) {
                    symbols.addElement(symbol)
                }
            }
            if (symbols.isEmpty()) {
                return null
            }
            symbols = moveConOrDesToStart(symbols)
            val result = arrayOfNulls<DisassemblerSymbol>(symbols.size)
            for (i in symbols.indices) {
                result[i] = symbols[i]
            }
            return result
        }

    private fun isVtable(sym: DisassemblerSymbol): Boolean {
        if (vtable == null) {
            return false
        }
        for (symbol in vtable.vtables) {
            if (symbol.demangledName == sym.demangledName) {
                return true
            }
        }
        return false
    }

    private fun moveConOrDesToStart(syms: Vector<DisassemblerSymbol>): Vector<DisassemblerSymbol> {
        val result = Vector<DisassemblerSymbol>()
        for (sym in syms) {
            if (isCon(sym)) {
                result.addElement(sym)
            }
        }
        for (sym in syms) {
            if (isDes(sym)) {
                result.addElement(sym)
            }
        }
        for (sym in syms) {
            if (!isDes(sym) && !isCon(sym)) {
                result.addElement(sym)
            }
        }
        return result
    }

    private fun isCon(symbol: DisassemblerSymbol): Boolean {
        try {
            val name = symbol.demangledName.substring(disassemblerClass.name.length + 2)
            if (name.startsWith(className)) {
                return true
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return false
    }

    private fun isDes(symbol: DisassemblerSymbol): Boolean {
        try {
            val name = symbol.demangledName.substring(disassemblerClass.name.length + 2)
            if (name.startsWith("~$className")) {
                return true
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return false
    }

    companion object {
        private fun hasItemInList(
            syms: Vector<DisassemblerSymbol>,
            sym: DisassemblerSymbol
        ): Boolean {
            for (iSym in syms) {
                if (sym.demangledName == iSym.demangledName) {
                    return false
                }
            }
            return true
        }

        private fun isObjectItem(sym: DisassemblerSymbol): Boolean {
            val dname = sym.demangledName
            val name = sym.name
            return !dname.contains("(") && !dname.contains(")") && name.startsWith("_ZN")
        }

        private fun isMethodItem(sym: DisassemblerSymbol): Boolean {
            val dname = sym.demangledName
            val name = sym.name
            return dname.contains("(") && dname.contains(")") && name.startsWith("_ZN")
        }
    }
}
